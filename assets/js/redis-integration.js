// Enhanced Portfolio JavaScript with Redis Backend Integration

// API Configuration
const API_CONFIG = {
    baseUrl: window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
        ? 'http://localhost:3001' 
        : 'https://your-backend-domain.com', // Update this for production
    endpoints: {
        visits: '/api/visits',
        analytics: '/api/analytics',
        contact: '/api/contact',
        contacts: '/api/contacts'
    }
};

// Redis-Based Visit Tracking Analytics
class RedisVisitTracker {
    constructor() {
        this.sessionKey = 'portfolio_session';
        this.visitorIdKey = 'portfolio_visitor_id';
        this.apiRetryCount = 3;
        this.apiRetryDelay = 1000;
        this.init();
    }

    init() {
        this.trackPageVisit();
        this.trackEngagement();
        this.setupVisibilityTracking();
        this.setupPerformanceTracking();
    }

    // Generate unique visitor ID
    generateVisitorId() {
        return 'visitor_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    // Get or create visitor ID
    getVisitorId() {
        let visitorId = localStorage.getItem(this.visitorIdKey);
        if (!visitorId) {
            visitorId = this.generateVisitorId();
            localStorage.setItem(this.visitorIdKey, visitorId);
        }
        return visitorId;
    }

    // Check if this is a new session
    isNewSession() {
        const sessionId = sessionStorage.getItem(this.sessionKey);
        if (!sessionId) {
            const newSessionId = 'session_' + Date.now();
            sessionStorage.setItem(this.sessionKey, newSessionId);
            return true;
        }
        return false;
    }

    // API utility with retry logic
    async apiRequest(endpoint, method = 'GET', data = null, retryCount = 0) {
        try {
            const config = {
                method,
                headers: {
                    'Content-Type': 'application/json',
                },
            };

            if (data) {
                config.body = JSON.stringify(data);
            }

            const response = await fetch(`${API_CONFIG.baseUrl}${endpoint}`, config);
            
            if (!response.ok) {
                throw new Error(`API request failed: ${response.status} ${response.statusText}`);
            }

            return await response.json();
        } catch (error) {
            console.warn(`API request failed (attempt ${retryCount + 1}):`, error);
            
            if (retryCount < this.apiRetryCount) {
                await new Promise(resolve => setTimeout(resolve, this.apiRetryDelay * (retryCount + 1)));
                return this.apiRequest(endpoint, method, data, retryCount + 1);
            }
            
            // Fallback to localStorage if API fails
            this.fallbackToLocalStorage(endpoint, data);
            throw error;
        }
    }

    // Fallback storage for when Redis API is unavailable
    fallbackToLocalStorage(endpoint, data) {
        try {
            const fallbackKey = `fallback_${endpoint.replace(/\//g, '_')}`;
            const existing = JSON.parse(localStorage.getItem(fallbackKey) || '[]');
            existing.push({ ...data, timestamp: new Date().toISOString(), offline: true });
            localStorage.setItem(fallbackKey, JSON.stringify(existing.slice(-100))); // Keep last 100
            console.log('Data stored in localStorage fallback');
        } catch (error) {
            console.error('Fallback storage failed:', error);
        }
    }

    // Track page visit to Redis
    async trackPageVisit() {
        const visitorId = this.getVisitorId();
        const isNewSession = this.isNewSession();

        const visitData = {
            visitorId,
            userAgent: navigator.userAgent,
            referrer: document.referrer || 'direct',
            url: window.location.href,
            viewport: {
                width: window.innerWidth,
                height: window.innerHeight
            },
            isNewSession,
            timestamp: new Date().toISOString()
        };

        try {
            const response = await this.apiRequest(API_CONFIG.endpoints.visits, 'POST', visitData);
            console.log('ðŸ“Š Visit tracked to Redis:', response);
            
            // Store the returned visitor ID in case it was generated by the server
            if (response.visitorId && response.visitorId !== visitorId) {
                localStorage.setItem(this.visitorIdKey, response.visitorId);
            }
            
            return response;
        } catch (error) {
            console.error('Failed to track visit to Redis:', error);
            return null;
        }
    }

    // Get analytics from Redis
    async getAnalytics() {
        try {
            const analytics = await this.apiRequest(API_CONFIG.endpoints.analytics);
            console.log('ðŸ“ˆ Analytics from Redis:', analytics);
            return analytics;
        } catch (error) {
            console.error('Failed to fetch analytics from Redis:', error);
            return {
                totalVisits: 0,
                totalSessions: 0,
                uniqueVisitors: 0,
                recentVisits: []
            };
        }
    }

    // Track engagement events
    trackEngagement() {
        const events = [
            { event: 'scroll', threshold: 25 },
            { event: 'scroll', threshold: 50 },
            { event: 'scroll', threshold: 75 },
            { event: 'scroll', threshold: 100 }
        ];

        let maxScroll = 0;
        const throttledScroll = this.throttle(() => {
            const scrollPercent = Math.round(
                (window.scrollY / (document.documentElement.scrollHeight - window.innerHeight)) * 100
            );
            
            if (scrollPercent > maxScroll) {
                maxScroll = scrollPercent;
                
                events.forEach(({ threshold }) => {
                    if (scrollPercent >= threshold && !this[`tracked_${threshold}`]) {
                        this[`tracked_${threshold}`] = true;
                        this.trackEvent('scroll_depth', { percentage: threshold });
                    }
                });
            }
        }, 100);

        window.addEventListener('scroll', throttledScroll, { passive: true });

        // Track time on page
        this.startTime = Date.now();
        window.addEventListener('beforeunload', () => {
            const timeSpent = Math.round((Date.now() - this.startTime) / 1000);
            this.trackEvent('time_on_page', { seconds: timeSpent });
        });
    }

    // Track custom events
    async trackEvent(eventType, eventData) {
        const eventPayload = {
            visitorId: this.getVisitorId(),
            eventType,
            eventData,
            timestamp: new Date().toISOString(),
            url: window.location.href
        };

        try {
            // Could extend API to track events
            console.log('ðŸ“Š Event tracked:', eventPayload);
        } catch (error) {
            console.error('Failed to track event:', error);
        }
    }

    // Setup visibility tracking
    setupVisibilityTracking() {
        let isVisible = !document.hidden;
        let visibilityStart = Date.now();

        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                if (isVisible) {
                    const visibleTime = Date.now() - visibilityStart;
                    this.trackEvent('visibility', { 
                        type: 'hidden',
                        visibleDuration: visibleTime 
                    });
                    isVisible = false;
                }
            } else {
                if (!isVisible) {
                    visibilityStart = Date.now();
                    this.trackEvent('visibility', { type: 'visible' });
                    isVisible = true;
                }
            }
        });
    }

    // Performance tracking
    setupPerformanceTracking() {
        window.addEventListener('load', () => {
            setTimeout(() => {
                if (window.performance && window.performance.timing) {
                    const timing = window.performance.timing;
                    const performanceData = {
                        loadTime: timing.loadEventEnd - timing.navigationStart,
                        domContentLoaded: timing.domContentLoadedEventEnd - timing.navigationStart,
                        firstPaint: timing.responseStart - timing.navigationStart
                    };
                    
                    this.trackEvent('performance', performanceData);
                }
            }, 1000);
        });
    }

    // Utility: Throttle function
    throttle(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

    // Display analytics in console (for debugging)
    async displayAnalytics() {
        try {
            const analytics = await this.getAnalytics();
            console.group('ðŸ“Š Portfolio Analytics (Redis)');
            console.log('Total Visits:', analytics.totalVisits);
            console.log('Total Sessions:', analytics.totalSessions);
            console.log('Unique Visitors:', analytics.uniqueVisitors);
            console.log('Recent Visits:', analytics.recentVisits);
            console.groupEnd();
            return analytics;
        } catch (error) {
            console.error('Failed to display analytics:', error);
        }
    }
}

// Enhanced Contact Form with Redis Integration
class RedisContactForm {
    constructor() {
        this.form = null;
        this.submitBtn = null;
        this.isSubmitting = false;
        this.init();
    }

    init() {
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => this.setupForm());
        } else {
            this.setupForm();
        }
    }

    setupForm() {
        this.form = document.getElementById('contactForm');
        this.submitBtn = document.getElementById('submitBtn');
        
        if (this.form) {
            this.form.addEventListener('submit', (e) => this.handleSubmit(e));
            this.setupFormValidation();
        }
    }

    setupFormValidation() {
        const inputs = this.form.querySelectorAll('input, textarea, select');
        inputs.forEach(input => {
            input.addEventListener('blur', () => this.validateField(input));
            input.addEventListener('input', () => this.clearFieldError(input));
        });
    }

    validateField(field) {
        const value = field.value.trim();
        let isValid = true;
        let errorMessage = '';

        // Required field validation
        if (field.hasAttribute('required') && !value) {
            isValid = false;
            errorMessage = `${field.labels[0]?.textContent || 'This field'} is required`;
        }

        // Email validation
        if (field.type === 'email' && value) {
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (!emailRegex.test(value)) {
                isValid = false;
                errorMessage = 'Please enter a valid email address';
            }
        }

        this.showFieldError(field, isValid ? '' : errorMessage);
        return isValid;
    }

    showFieldError(field, message) {
        const errorElement = document.getElementById(`${field.id}-error`);
        if (errorElement) {
            errorElement.textContent = message;
            errorElement.classList.toggle('sr-only', !message);
        }
        
        field.classList.toggle('error', !!message);
        field.setAttribute('aria-invalid', !!message);
    }

    clearFieldError(field) {
        this.showFieldError(field, '');
    }

    async handleSubmit(e) {
        e.preventDefault();
        
        if (this.isSubmitting) return;

        // Validate all fields
        const inputs = this.form.querySelectorAll('input, textarea, select');
        let isFormValid = true;
        
        inputs.forEach(input => {
            if (!this.validateField(input)) {
                isFormValid = false;
            }
        });

        if (!isFormValid) {
            AccessibilityUtils.announce('Please correct the errors in the form');
            return;
        }

        this.isSubmitting = true;
        this.updateSubmitButton(true);

        try {
            const formData = new FormData(this.form);
            const contactData = {
                name: formData.get('name'),
                email: formData.get('email'),
                company: formData.get('company'),
                project: formData.get('project'),
                timeline: formData.get('timeline'),
                message: formData.get('message'),
                visitorId: visitTracker.getVisitorId()
            };

            const response = await visitTracker.apiRequest(
                API_CONFIG.endpoints.contact, 
                'POST', 
                contactData
            );

            this.showSuccessMessage(response.message);
            this.form.reset();
            
            // Close modal after success
            setTimeout(() => {
                if (typeof closeContactModal === 'function') {
                    closeContactModal();
                }
            }, 2000);

        } catch (error) {
            console.error('Contact form submission failed:', error);
            this.showErrorMessage('Failed to send message. Please try again or contact directly.');
        } finally {
            this.isSubmitting = false;
            this.updateSubmitButton(false);
        }
    }

    updateSubmitButton(loading) {
        if (!this.submitBtn) return;

        const span = this.submitBtn.querySelector('span');
        const icon = this.submitBtn.querySelector('i');
        
        if (loading) {
            this.submitBtn.disabled = true;
            if (span) span.textContent = 'Sending...';
            if (icon) {
                icon.className = 'fas fa-spinner fa-spin';
            }
        } else {
            this.submitBtn.disabled = false;
            if (span) span.textContent = 'Send Message';
            if (icon) {
                icon.className = 'fas fa-paper-plane';
            }
        }
    }

    showSuccessMessage(message) {
        this.showMessage(message, 'success');
        AccessibilityUtils.announce('Message sent successfully');
    }

    showErrorMessage(message) {
        this.showMessage(message, 'error');
        AccessibilityUtils.announce('Failed to send message');
    }

    showMessage(message, type) {
        // Create or update message element
        let messageEl = this.form.querySelector('.form-message');
        if (!messageEl) {
            messageEl = document.createElement('div');
            messageEl.className = 'form-message';
            messageEl.setAttribute('role', 'status');
            messageEl.setAttribute('aria-live', 'polite');
            this.form.appendChild(messageEl);
        }

        messageEl.textContent = message;
        messageEl.className = `form-message ${type}`;
        
        // Auto-hide after 5 seconds
        setTimeout(() => {
            messageEl.textContent = '';
            messageEl.className = 'form-message';
        }, 5000);
    }
}

// Initialize Redis-based systems
const visitTracker = new RedisVisitTracker();
const contactForm = new RedisContactForm();

// Make analytics available globally for debugging
window.getAnalytics = () => visitTracker.displayAnalytics();
window.trackEvent = (type, data) => visitTracker.trackEvent(type, data);

// Debug info
console.log('ðŸš€ Redis-integrated portfolio analytics initialized');
console.log('ðŸ“Š Use getAnalytics() to view current stats');
console.log('ðŸ“ˆ Use trackEvent(type, data) to track custom events');